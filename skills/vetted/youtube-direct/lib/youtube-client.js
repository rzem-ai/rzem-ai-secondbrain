#!/usr/bin/env node

/**
 * YouTube Direct API Client
 *
 * Wrapper around Google's official YouTube Data API v3
 * Handles authentication (OAuth2 and API key) and common operations
 */

const { google } = require('googleapis');
const fs = require('fs');
const path = require('path');
const os = require('os');

class YouTubeClient {
  constructor() {
    this.youtube = null;
    this.auth = null;
    this.configDir = this.getConfigDir();
    this.ensureConfigDir();
  }

  /**
   * Get configuration directory path
   */
  getConfigDir() {
    const home = os.homedir();
    // Try OpenClaw directory first, fallback to skill directory
    const openclawDir = path.join(home, '.openclaw', 'skills', 'youtube-direct');
    const skillDir = path.join(__dirname, '..', 'credentials');

    return fs.existsSync(path.join(home, '.openclaw')) ? openclawDir : skillDir;
  }

  /**
   * Ensure config directory exists with secure permissions
   */
  ensureConfigDir() {
    const credDir = path.join(this.configDir, 'credentials');
    if (!fs.existsSync(credDir)) {
      fs.mkdirSync(credDir, { recursive: true, mode: 0o700 });
    }
    // Ensure directory has restrictive permissions
    try {
      fs.chmodSync(credDir, 0o700);
    } catch (e) {
      console.warn(`Warning: Could not set permissions on ${credDir}`);
    }
  }

  /**
   * Initialize with OAuth2 credentials
   */
  async initWithOAuth(clientSecretPath, tokenPath = null) {
    if (!tokenPath) {
      tokenPath = path.join(this.configDir, 'credentials', 'tokens.json');
    }

    // Read client secrets
    const credentials = JSON.parse(fs.readFileSync(clientSecretPath, 'utf8'));
    const { client_secret, client_id, redirect_uris } =
      credentials.installed || credentials.web;

    // Create OAuth2 client
    const oAuth2Client = new google.auth.OAuth2(
      client_id,
      client_secret,
      redirect_uris[0]
    );

    // Load saved tokens if they exist
    if (fs.existsSync(tokenPath)) {
      const tokens = JSON.parse(fs.readFileSync(tokenPath, 'utf8'));
      oAuth2Client.setCredentials(tokens);
    }

    this.auth = oAuth2Client;
    this.youtube = google.youtube({ version: 'v3', auth: oAuth2Client });

    return this;
  }

  /**
   * Initialize with API key (limited functionality)
   */
  initWithApiKey(apiKey = null) {
    if (!apiKey) {
      apiKey = process.env.YOUTUBE_API_KEY;
    }

    if (!apiKey) {
      throw new Error('No API key provided. Set YOUTUBE_API_KEY environment variable or pass as parameter.');
    }

    this.auth = apiKey;
    this.youtube = google.youtube({ version: 'v3', auth: apiKey });

    return this;
  }

  /**
   * Get video details including metadata
   */
  async getVideoDetails(videoId) {
    try {
      const response = await this.youtube.videos.list({
        part: ['snippet', 'contentDetails', 'statistics'],
        id: [videoId]
      });

      if (!response.data.items || response.data.items.length === 0) {
        throw new Error(`Video not found: ${videoId}`);
      }

      const video = response.data.items[0];
      return {
        id: video.id,
        title: video.snippet.title,
        description: video.snippet.description,
        channel: {
          id: video.snippet.channelId,
          title: video.snippet.channelTitle
        },
        publishedAt: video.snippet.publishedAt,
        duration: video.contentDetails.duration,
        viewCount: parseInt(video.statistics.viewCount || 0),
        likeCount: parseInt(video.statistics.likeCount || 0),
        thumbnails: video.snippet.thumbnails
      };
    } catch (error) {
      throw new Error(`Failed to get video details: ${error.message}`);
    }
  }

  /**
   * Get available captions for a video
   */
  async getAvailableCaptions(videoId) {
    if (typeof this.auth === 'string') {
      throw new Error('Captions require OAuth2 authentication. API keys are not sufficient.');
    }

    try {
      const response = await this.youtube.captions.list({
        part: ['snippet'],
        videoId: videoId
      });

      return response.data.items.map(caption => ({
        id: caption.id,
        language: caption.snippet.language,
        name: caption.snippet.name,
        trackKind: caption.snippet.trackKind,
        isAutoGenerated: caption.snippet.trackKind === 'ASR'
      }));
    } catch (error) {
      if (error.code === 403) {
        throw new Error('Captions are disabled for this video or you lack permission.');
      }
      throw new Error(`Failed to get captions: ${error.message}`);
    }
  }

  /**
   * Download caption/transcript
   */
  async downloadCaption(captionId, format = 'srt') {
    if (typeof this.auth === 'string') {
      throw new Error('Caption download requires OAuth2 authentication.');
    }

    try {
      const response = await this.youtube.captions.download({
        id: captionId,
        tfmt: format // srt, sbv, vtt
      });

      return response.data;
    } catch (error) {
      throw new Error(`Failed to download caption: ${error.message}`);
    }
  }

  /**
   * Get transcript for a video (convenience method)
   */
  async getTranscript(videoId, options = {}) {
    const { language = null, preferAutoGenerated = true } = options;

    // Get video details
    const videoDetails = await this.getVideoDetails(videoId);

    // Get available captions
    const captions = await this.getAvailableCaptions(videoId);

    if (captions.length === 0) {
      throw new Error('No captions available for this video');
    }

    // Select caption track
    let selectedCaption = null;

    if (language) {
      // Try to find exact language match
      selectedCaption = captions.find(c => c.language === language);
      if (!selectedCaption) {
        throw new Error(`No captions available in language: ${language}`);
      }
    } else {
      // Use auto-generated if preferred and available, otherwise first available
      if (preferAutoGenerated) {
        selectedCaption = captions.find(c => c.isAutoGenerated) || captions[0];
      } else {
        selectedCaption = captions.find(c => !c.isAutoGenerated) || captions[0];
      }
    }

    // Download the caption
    const captionText = await this.downloadCaption(selectedCaption.id, 'srt');

    // Parse SRT format into structured data
    const transcript = this.parseSRT(captionText);

    return {
      video_id: videoId,
      title: videoDetails.title,
      channel: videoDetails.channel.title,
      language: selectedCaption.language,
      is_auto_generated: selectedCaption.isAutoGenerated,
      transcript: transcript
    };
  }

  /**
   * Parse SRT subtitle format into structured data
   */
  parseSRT(srtText) {
    const entries = [];
    const blocks = srtText.trim().split('\n\n');

    for (const block of blocks) {
      const lines = block.split('\n');
      if (lines.length < 3) continue;

      // Line 0: sequence number (skip)
      // Line 1: timestamp
      const timeMatch = lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3})\s-->\s(\d{2}:\d{2}:\d{2},\d{3})/);
      if (!timeMatch) continue;

      const startTime = this.srtTimeToSeconds(timeMatch[1]);
      const endTime = this.srtTimeToSeconds(timeMatch[2]);

      // Line 2+: text
      const text = lines.slice(2).join(' ').trim();

      entries.push({
        text: text,
        start: startTime,
        duration: endTime - startTime
      });
    }

    return entries;
  }

  /**
   * Convert SRT timestamp to seconds
   */
  srtTimeToSeconds(timestamp) {
    const parts = timestamp.split(':');
    const hours = parseInt(parts[0]);
    const minutes = parseInt(parts[1]);
    const secondsParts = parts[2].split(',');
    const seconds = parseInt(secondsParts[0]);
    const milliseconds = parseInt(secondsParts[1]);

    return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
  }

  /**
   * Search videos or channels
   */
  async search(query, options = {}) {
    const {
      type = 'video', // video, channel, playlist
      maxResults = 20,
      order = 'relevance', // date, rating, relevance, title, videoCount, viewCount
      regionCode = null,
      videoDuration = null // any, short, medium, long
    } = options;

    try {
      const params = {
        part: ['snippet'],
        q: query,
        type: [type],
        maxResults: maxResults,
        order: order
      };

      if (regionCode) params.regionCode = regionCode;
      if (videoDuration && type === 'video') params.videoDuration = videoDuration;

      const response = await this.youtube.search.list(params);

      return response.data.items.map(item => ({
        type: item.id.kind.replace('youtube#', ''),
        id: item.id.videoId || item.id.channelId || item.id.playlistId,
        title: item.snippet.title,
        description: item.snippet.description,
        channelTitle: item.snippet.channelTitle,
        channelId: item.snippet.channelId,
        publishedAt: item.snippet.publishedAt,
        thumbnails: item.snippet.thumbnails
      }));
    } catch (error) {
      throw new Error(`Search failed: ${error.message}`);
    }
  }

  /**
   * Get channel details
   */
  async getChannelDetails(channelId) {
    try {
      const response = await this.youtube.channels.list({
        part: ['snippet', 'statistics', 'contentDetails'],
        id: [channelId]
      });

      if (!response.data.items || response.data.items.length === 0) {
        throw new Error(`Channel not found: ${channelId}`);
      }

      const channel = response.data.items[0];
      return {
        id: channel.id,
        title: channel.snippet.title,
        description: channel.snippet.description,
        customUrl: channel.snippet.customUrl,
        publishedAt: channel.snippet.publishedAt,
        subscriberCount: parseInt(channel.statistics.subscriberCount || 0),
        videoCount: parseInt(channel.statistics.videoCount || 0),
        viewCount: parseInt(channel.statistics.viewCount || 0),
        uploadsPlaylistId: channel.contentDetails.relatedPlaylists.uploads,
        thumbnails: channel.snippet.thumbnails
      };
    } catch (error) {
      throw new Error(`Failed to get channel details: ${error.message}`);
    }
  }

  /**
   * Get videos from a channel
   */
  async getChannelVideos(channelId, maxResults = 50) {
    try {
      // First get the uploads playlist ID
      const channelDetails = await this.getChannelDetails(channelId);
      const uploadsPlaylistId = channelDetails.uploadsPlaylistId;

      // Get videos from the uploads playlist
      const response = await this.youtube.playlistItems.list({
        part: ['snippet', 'contentDetails'],
        playlistId: uploadsPlaylistId,
        maxResults: maxResults
      });

      return response.data.items.map(item => ({
        videoId: item.contentDetails.videoId,
        title: item.snippet.title,
        description: item.snippet.description,
        publishedAt: item.snippet.publishedAt,
        thumbnails: item.snippet.thumbnails
      }));
    } catch (error) {
      throw new Error(`Failed to get channel videos: ${error.message}`);
    }
  }

  /**
   * Get videos from a playlist
   */
  async getPlaylistVideos(playlistId, maxResults = 50) {
    try {
      const response = await this.youtube.playlistItems.list({
        part: ['snippet', 'contentDetails'],
        playlistId: playlistId,
        maxResults: maxResults
      });

      return response.data.items.map(item => ({
        videoId: item.contentDetails.videoId,
        title: item.snippet.title,
        description: item.snippet.description,
        position: item.snippet.position,
        publishedAt: item.snippet.publishedAt,
        thumbnails: item.snippet.thumbnails
      }));
    } catch (error) {
      throw new Error(`Failed to get playlist videos: ${error.message}`);
    }
  }
}

module.exports = { YouTubeClient };
